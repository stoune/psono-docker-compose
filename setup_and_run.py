#!/usr/bin/env python3

import os
import argparse
import shutil
import subprocess
import logging
from dataclasses import dataclass
from typing import List, Dict
import secrets

# --- Constants ---
DEFAULT_PASSWORD_LENGTH = 32
# Default log level
DEFAULT_VERBOSITY = 0
DEFAULT_DB_HOST = "localhost"
DEFAULT_DB_SERVICE = "db"
DEFAULT_DB_PORT = 5432
DEFAULT_DB_NAME = "psono"
DEFAULT_DB_USER = "psono"

DEFAULT_SMTP_PORT = 1025
DEFAULT_SMTP_HOST = "mailserver"
DEFAULT_EMAIL_WEBUI_PORT = 8025
DEFAULT_EMAIL_HOST_USER = ""
DEFAULT_EMAIL_HOST_PASSWORD = ""
DEFAULT_EMAIL_FROM = "webadmin@example.com"
DEFAULT_EMAIL_BACKEND = "restapi.email_backend.CustomSSLEmailBackend"

DEFAULT_DJANGO_SUPERUSER_USERNAME = "admin"
DEFAULT_CERT_NAME = "mailserver"
DEFAULT_CERT_DIR = "certs"
DEFAULT_WEB_CLIENT_URL = "http://localhost:10200"
DEFAULT_HOST_URL = "http://localhost:10200/server"

# Script directory
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))

# Set up logging
logger = logging.getLogger(__name__)
logging.basicConfig(format="%(levelname)s: %(message)s")


# Settings template
SETTINGS_TEMPLATE = """
# Replace these keys with the ones generated by the command below.
SECRET_KEY: '{secret_key}'
ACTIVATION_LINK_SECRET: '{activation_link_secret}'
DB_SECRET: '{db_secret}'
EMAIL_SECRET_SALT: '{email_secret_salt}'
PRIVATE_KEY: '{private_key}'
PUBLIC_KEY: '{public_key}'

# Web client URL (adjust as necessary)
WEB_CLIENT_URL: '{web_client_url}'

# Switch DEBUG to true for development purposes
DEBUG: True

# Allowed hosts and domains for development (use '*' for local testing)
ALLOWED_HOSTS: ['*']
ALLOWED_DOMAINS: ['localhost']

# Email configuration (adjust for your SMTP server)
EMAIL_BACKEND: {email_backend} 
EMAIL_FROM: '{email_from}'
EMAIL_HOST: '{email_host}'
EMAIL_HOST_USER: '{email_host_user}'
EMAIL_HOST_PASSWORD: '{email_host_password}'
EMAIL_PORT: {email_port}
EMAIL_USE_TLS: {email_use_tls}

# Database configuration (using localhost for development)
DATABASES:
  default:
    ENGINE: 'django.db.backends.postgresql_psycopg2'
    NAME: '{postgres_db}'
    USER: '{postgres_user}'
    PASSWORD: '{postgres_password}'
    HOST: '{postgres_host}'
    PORT: '{postgres_port}'

HOST_URL: '{host_url}'

MANAGEMENT_ENABLED: True
"""

# .env content template
ENV_CONTENT_TEMPLATE = """CERT_NAME={cert_name}
CERT_DIR={cert_dir}

POSTGRES_HOST={db_service}
POSTGRES_PORT={db_port}
POSTGRES_DB={db_name}
POSTGRES_USER={db_user}
POSTGRES_PASSWORD='{db_password}'

EMAIL_HOST={email_host}
EMAIL_SMTP_PORT={smtp_port}
EMAIL_WEB_PORT={email_webui_port}

PSONO_EMAIL_HOST_USER={email_host_user}
PSONO_EMAIL_HOST_PASSWORD='{email_host_pwd}'
PSONO_EMAIL_FROM={email_from}
EMAIL_BACKEND={email_backend}

PSONO_SECRET_KEY='{secret_key}'
PSONO_ACTIVATION_LINK_SECRET='{activation_link_secret}'
PSONO_DB_SECRET='{db_secret}'
PSONO_EMAIL_SECRET_SALT='{email_secret_salt}'
PSONO_PRIVATE_KEY='{private_key}'
PSONO_PUBLIC_KEY='{public_key}'

DJANGO_SUPERUSER_USERNAME={django_superuser_username}
DJANGO_SUPERUSER_PASSWORD='{django_superuser_password}'
DJANGO_SUPERUSER_EMAIL={email_from}
DJANGO_SECRET_KEY='{django_secret_key}'

DOCKER_UID={docker_uid}
DOCKER_GID={docker_gid}
"""


@dataclass
class Config:
    """Configuration class for Psono setup."""

    secret_key: str = ""
    activation_link_secret: str = ""
    db_secret: str = ""
    email_secret_salt: str = ""
    private_key: str = ""
    public_key: str = ""
    
    django_superuser_password: str = ""
    django_secret_key: str = ""
    cert_name: str = DEFAULT_CERT_NAME
    cert_dir: str = DEFAULT_CERT_DIR

    db_service: str = DEFAULT_DB_SERVICE
    db_port: int = DEFAULT_DB_PORT
    db_name: str = DEFAULT_DB_NAME
    db_user: str = DEFAULT_DB_USER
    db_password: str = ""

    email_host: str = 'mailserver'
    smtp_port: int = DEFAULT_SMTP_PORT
    email_webui_port: int = DEFAULT_EMAIL_WEBUI_PORT
    email_host_user: str = DEFAULT_EMAIL_HOST_USER
    email_host_pwd: str = DEFAULT_EMAIL_HOST_PASSWORD
    email_from: str = "psonoadmin@not.existent.domain"
    email_backend: str = DEFAULT_EMAIL_BACKEND
    django_superuser_username: str = DEFAULT_DJANGO_SUPERUSER_USERNAME
    docker_uid: str = str(os.getuid())
    docker_gid: str = str(os.getgid())
    web_client_url: str = "http://localhost:10200"
    host_url: str = "http://localhost:10200/server"
    email_host: str = "smtp.example.com"
    email_use_tls: bool = True


def generate_random_password(length: int = DEFAULT_PASSWORD_LENGTH) -> str:
    """Generate a random password."""
    return secrets.token_urlsafe(length)


def escape_value(value: str) -> str:
    """Escape special characters for .env file, including $."""
    if value is None:
        return ""
    return (
        value.replace("\\", "\\\\")
        .replace('"', '\\"')
        .replace("`", "\\`")
        .replace("'", "'\\''")
        .replace("$", "\\$")
        .replace("\n", "\\n")
    )


def check_docker_compose() -> None:
    """Check if Docker Compose is installed."""
    try:
        subprocess.run(
            ["docker", "compose", "version"],
            check=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )
        logger.debug("Docker Compose is installed as a docker subcommand.")
    except subprocess.CalledProcessError:
        try:
            subprocess.run(
                ["docker-compose", "--version"],
                check=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
            )
            logger.debug("Docker Compose is installed as a standalone binary.")
        except subprocess.CalledProcessError:
            logger.error("Docker Compose is not installed.")
            exit(1)


def show_warning(clean_data : bool, regenerate_keys: bool) -> bool:
    """Display warning and get user confirmation."""
    if clean_data or regenerate_keys:
        logger.warning("This script will cleanup the data and regenerate new .env.")
        user_input = input("Do you want to continue? (y/n): ").lower()
        if user_input != "y":
            logger.info("Operation canceled by the user.")
            return False
    return True


def generate_psono_keys() -> Dict[str, str]:
    """Generate Psono server keys and return them as a dictionary."""
    logger.debug("Running docker command to generate Psono keys")
    result = subprocess.run(
        [
            "docker", "run", "--rm", "psono/psono-combo:latest",
            "python3", "./psono/manage.py", "generateserverkeys",
        ],
        capture_output=True,
        text=True,
        check=True,
    )

    expected_keys = {
        "SECRET_KEY",
        "ACTIVATION_LINK_SECRET",
        "DB_SECRET",
        "EMAIL_SECRET_SALT",
        "PRIVATE_KEY",
        "PUBLIC_KEY",
    }

    keys = {}
    for line in result.stdout.split("\n"):
        line = line.strip()
        if (
            not line
            or line.startswith("#")
            or "WARNING" in line
            or "Copy paste" in line
        ):
            continue
        if ": " in line:
            key, value = line.split(": ", 1)
            if key in expected_keys:
                value = value.strip("'").strip('"')
                keys[key] = value
                logger.info(f"Generated {key}")

    missing_keys = expected_keys - set(keys.keys())
    if missing_keys:
        logger.warning(f"Missing expected keys: {missing_keys}")

    return keys


def generate_certificates(cert_dir: str, cert_name: str) -> None:
    """Generate TLS certificates."""
    certs_dir = os.path.join(SCRIPT_DIR, cert_dir)

    if not os.path.isfile(os.path.join(certs_dir, "generate_certificates.sh")):
        logger.error(f"generate_certificates.sh not found in {certs_dir}")
        exit(1)

    if not cert_name:
        logger.error("Certificate name not provided.")
        exit(1)

    logger.debug(f"Generating certificates in {certs_dir} with name {cert_name}")
    subprocess.run(
        [
            "docker", "run", "--rm", 
            "-v", f"{certs_dir}:/certs",
            "-w", "/certs",
            "-e", f"CERT_NAME={cert_name}",
            "alpine", "sh", "generate_certificates.sh",
        ],
        check=True,
    )

def prepare_config_values(args: argparse.Namespace, psono_keys: Dict[str, str]) -> Config:
    """Prepare configuration values by checking args and psono_keys, generating passwords."""
    config = Config()

    # Secrets: Prioritize psono_keys over args
    config.secret_key = psono_keys.get("SECRET_KEY", args.secret_key or "")
    config.activation_link_secret = psono_keys.get(
        "ACTIVATION_LINK_SECRET", args.activation_link_secret or ""
    )
    config.db_secret = psono_keys.get("DB_SECRET", args.db_secret or "")
    config.email_secret_salt = psono_keys.get(
        "EMAIL_SECRET_SALT", args.email_secret_salt or ""
    )
    config.private_key = psono_keys.get("PRIVATE_KEY", args.private_key or "")
    config.public_key = psono_keys.get("PUBLIC_KEY", args.public_key or "")

    config.django_superuser_password = generate_random_password(16)
    config.django_secret_key = generate_random_password(16)

    # Other configuration values from args
    config.cert_name = args.cert_name
    config.cert_dir = args.cert_dir
    
    config.db_service = args.db_host
    config.db_port = args.db_port
    config.db_name = args.db_name
    config.db_user = args.db_user
    # Passwords: Generate if not provided
    config.db_password = args.db_pwd or generate_random_password(16)
    
    config.smtp_port = args.smtp_port
    config.email_webui_port = args.email_webui_port
    config.email_host_user = args.email_host_user or ""  # Keep empty string if None
    config.email_host_pwd = args.email_host_pwd or ""  # Keep empty string if None
    config.email_from = args.email_from
    config.web_client_url = getattr(args, 'web_client_url', config.web_client_url)
    config.host_url = getattr(args, 'host_url', config.host_url)
    config.email_host = getattr(args, 'email_host', config.email_host)

    return config

def run_docker_compose_command(command: List[str], is_debug: bool) -> None:
    """Run a Docker Compose command with optional verbosity."""
    full_command = ["docker", "compose", "-f", "docker-compose.yml"]
    if is_debug:
      full_command.append("--verbose")
    full_command.extend(command)
    subprocess.run(full_command, check=True)

def inject_settings(config: Config, output_file: str = "./config/settings.yaml") -> None:
    """Inject settings into settings.yaml using prepared config values."""
    settings = SETTINGS_TEMPLATE.format(
        secret_key=config.secret_key,
        activation_link_secret=config.activation_link_secret,
        db_secret=config.db_secret,
        email_secret_salt=config.email_secret_salt,
        private_key=config.private_key,
        public_key=config.public_key,
        web_client_url=config.web_client_url,
        email_backend=config.email_backend,
        email_from=config.email_from,
        email_host=config.email_host,
        email_host_user=config.email_host_user,
        email_host_password=config.email_host_pwd,
        email_port=config.smtp_port,
        email_use_tls=config.email_use_tls,
        postgres_db=config.db_name,
        postgres_user=config.db_user,
        postgres_password=config.db_password,
        postgres_host=config.db_service,
        postgres_port=config.db_port,
        host_url=config.host_url
    )

    os.makedirs(os.path.dirname(output_file), exist_ok=True)
    with open(output_file, "w") as f:
        f.write(settings)
    logger.info(f"Generated settings file: {output_file}")


def generate_env(config: Config) -> None:
    """Generate .env file using prepared config values."""
    env_content = ENV_CONTENT_TEMPLATE.format(
        cert_name=config.cert_name,
        cert_dir=config.cert_dir,
        db_service=config.db_service,
        db_port=config.db_port,
        db_name=config.db_name,
        db_user=config.db_user,
        db_password=config.db_password,
        
        smtp_port=config.smtp_port,
        email_host=config.email_host,
        email_webui_port=config.email_webui_port,
        email_host_user=config.email_host_user,
        email_host_pwd=config.email_host_pwd,
        email_from=config.email_from,
        email_backend=config.email_backend,
        
        secret_key=config.secret_key,
        activation_link_secret=config.activation_link_secret,
        db_secret=config.db_secret,
        email_secret_salt=config.email_secret_salt,
        private_key=config.private_key,
        public_key=config.public_key,
        
        django_superuser_username=config.django_superuser_username,
        django_superuser_password=config.django_superuser_password,
        django_secret_key=config.django_secret_key,
        
        docker_uid=config.docker_uid,
        docker_gid=config.docker_gid,
    )

    with open(".env", "w") as f:
        f.write(env_content)
    logger.info(".env file generated successfully.")


def main():
    parser = argparse.ArgumentParser(description="Setup Psono environment with Docker Compose")
    parser.add_argument("--secret-key", help="Django app secret key")
    parser.add_argument("--activation-link-secret", help="Django app activation link secret key")
    parser.add_argument("--email-secret-salt", help="Django app email secret salt key")
    parser.add_argument("--private-key", help="Django app private key")
    parser.add_argument("--public-key", help="Django app public key")

    parser.add_argument("--db-secret", help="Django Database secret")
    parser.add_argument("--db-name", default=DEFAULT_DB_NAME, help="Database name")
    parser.add_argument("--db-user", default=DEFAULT_DB_USER, help="Database user")
    parser.add_argument("--db-pwd", help="Database password")
    parser.add_argument("--db-host", default=DEFAULT_DB_SERVICE, help="Database service name (default: db)")
    parser.add_argument("--db-port", type=int, default=DEFAULT_DB_PORT, help="Database port")

    parser.add_argument("--smtp-port", type=int, default=DEFAULT_SMTP_PORT, help="SMTP port")
    parser.add_argument(
        "--email-webui-port",
        type=int,
        default=DEFAULT_EMAIL_WEBUI_PORT,
        help="Email WebUI port",
    )
    parser.add_argument(
        "--email-host-user", default=DEFAULT_EMAIL_HOST_USER, help="Email host user"
    )
    parser.add_argument(
        "--email-host-pwd", default=DEFAULT_EMAIL_HOST_PASSWORD, help="Email host password"
    )
    parser.add_argument(
        "--email-from",
        default="psonoadmin@not.existent.domain",
        help="Email from address",
    )
    parser.add_argument("--cert-name", default=DEFAULT_CERT_NAME, help="Certificate name")
    parser.add_argument("--cert-dir", default=DEFAULT_CERT_DIR, help="Certificate directory")
    parser.add_argument(
        "--regenerate-keys", action="store_true", help="Regenerate keys"
    )
    parser.add_argument("--clean-data", action="store_true", help="Clean data")
    parser.add_argument(
        "-v",
        "--verbose",
        action="count",
        default=DEFAULT_VERBOSITY,
        help="Increase verbosity (default: INFO, -v for DEBUG, no -v for WARNING)",
    )
    parser.add_argument(
        "--web-client-url",
        default=DEFAULT_WEB_CLIENT_URL,
        help="Web client URL",
    )
    parser.add_argument(
        "--host-url",
        default=DEFAULT_HOST_URL,
        help="Host URL",
    )
        
    parser.add_argument(
        "--email-host",
        default=DEFAULT_SMTP_HOST,
        help="Email host",
    )

    args = parser.parse_args()

    # Configure logging based on verbosity level
    verbosity = args.verbose
    is_debug = verbosity >= 2  # True if level is DEBUG
    if verbosity >= 2:
        logger.setLevel(logging.DEBUG)
    elif verbosity == 1:
        logger.setLevel(logging.INFO)
    else:
        logger.setLevel(logging.WARNING)

    logger.debug("Starting script with arguments: %s", args)

    check_docker_compose()
    if not show_warning(clean_data=args.clean_data, regenerate_keys=args.regenerate_keys):
        exit(0)

    down_command = ["down"]
    if args.clean_data:
        logger.info("Cleaning docker compose data")
        down_command.append("-v")
    
    try:
        run_docker_compose_command(down_command, is_debug)
    except subprocess.CalledProcessError as e:
        logger.error(
            "Failed to down docker compose data with exit code %s: %s",
            e.returncode,
            e.cmd,
        )
        logger.info("Continuing despite the error...")

    psono_keys = {}
    if args.regenerate_keys:
        logger.info("Generating new psono keys")
        psono_keys = generate_psono_keys()

        logger.info("Generating new TLS certificates")
        generate_certificates(args.cert_dir, args.cert_name)

        # Prepare configuration values
        config = prepare_config_values(args, psono_keys)

        logger.info("Generating new .env file")
        generate_env(config)

        logger.info("Injecting settings into settings.yaml")
        inject_settings(config)

    logger.debug("Building Docker Compose services")
    run_docker_compose_command(["build"], is_debug)

    logger.debug("Starting Docker Compose services")
    run_docker_compose_command(["up", "-d"], is_debug)
    logger.info("Environment setup completed successfully.")


if __name__ == "__main__":
    try:
        main()
    except subprocess.CalledProcessError as e:
        logger.error("Command failed with exit code %s: %s", e.returncode, e.cmd)
        exit(1)
    except Exception as e:
        logger.error("Unexpected error: %s", str(e))
        exit(1)